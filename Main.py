# coding : utf-8import ffmpegimport glob2import osimport numpy as npimport copyfrom PIL import Image, ImageFilter, ImageDraw# import dropboximport posixpath# from dropbox.exceptions import ApiError# import qrcodeimport pygamefrom pygame.locals import *import syslist_serialNum = ["Canon EOS Kiss X8i (211032004233)","Canon EOS Kiss X8i (211032004234)","Canon EOS Kiss X8i (211032004209)","Canon EOS Kiss X8i (211032004210)","Canon EOS Kiss X8i (211032004212)","Canon EOS Kiss X8i (211032004211)","Canon EOS Kiss X8i (211032004213)","Canon EOS Kiss X8i (211032004214)","Canon EOS Kiss X8i (211032004230)","Canon EOS Kiss X8i (211032004229)","Canon EOS Kiss X8i (211032004228)","Canon EOS Kiss X8i (211032004227)","Canon EOS Kiss X8i (211032004238)","Canon EOS Kiss X8i (211032004237)","Canon EOS Kiss X8i (211032004235)","Canon EOS Kiss X8i (211032004236)","Canon EOS Kiss X8i (211032004166)","Canon EOS Kiss X8i (211032004162)","Canon EOS Kiss X8i (211032004164)","Canon EOS Kiss X8i (211032004165)","Canon EOS Kiss X8i (211032004232)","Canon EOS Kiss X8i (211032004231)","Canon EOS Kiss X8i (211032004161)"]# Setting Pathdir = '/Users/yu_mbp/Desktop/Session1/'dirMov = '/Users/yu_mbp/Desktop/mp4/'count = 0""""""def getImageList():    fList = glob2.glob(dir + '*.jpg')    num = len(list_serialNum)    list_cam = []    for i in range(23):        l = []        list_cam.append(l)    for i in range(num):        # dir = '/Users/Yu/Pictures/digiCamControl/Session1\\'        file_name = dir + str(list_serialNum[i])        n = len(fList)        for j in range(n):            # print("LIST : "+f)            if fList[j].find(list_serialNum[i]) > -1:                # os.remove(dir + str("{0:02d}".format(j))+".jpg")                # f = os.rename(fList[i], dir + str("{0:02d}".format(j))+".jpg")                list_cam[i].append(fList[j])                # print("RENAME : "+dir + str("{0:04d}".format(j))+".jpg")        print(str(i) +' : ' + str(list_cam[i]))    return list_cam""""""def deleteAllImages():    l = glob2.glob(dir+'*')    for i in l:        os.remove(i)def rename(camList):    sortedList = []    count = 0    l1 = camList[1]    print("camList[0] : "+str(len(l1)))    n = len(l1)    for i in range(n):        for imgList in camList:            imgList.sort()            print("i "+str(i))            tmp = imgList[i]            sortedList.append(tmp)            # f = os.rename(camList[i], dir+str("{0:04d}".format(count))+'.jpg')            # sortedList.append(f)            # print("RENAME : "+dir+str("{0:04d}".format(count))+'.jpg')            # count+=1        # for imgList in camList:        #     imgList.sort(reverse=True)        #     print(str(imgList[i]))        #     sortedList.append(imgList[i])        #     # count+=1    print(str(sortedList))    return sortedListdef compositeImage(sortedList, overlay_image):    result = "result/test_output.m4v"    # fps = movie.get(cv2.CAP_PROP_FPS)    # height = movie.get(cv2.CAP_PROP_FRAME_HEIGHT)    # width = movie.get(cv2.CAP_PROP_FRAME_WIDTH)    fps = 10    # fourcc = cv2.VideoWriter_fourcc('m', 'p', '4', 'v')    # video = cv2.VideoWriter(dirMov + 'video.mp4', fourcc, 10.0, (1080, 1080))    #    compositedList = []    size = (1080, 1080)    tmp = Image.new("RGBA", size, (0, 0, 0))    # out = cv2.VideoWriter(result, int(fourcc), fps, size)    count = 0    for i in sortedList:        s = (1080, 720)        img = Image.open(i)        img_resize = img.resize(s, resample=0)        tmp.paste(img_resize, (0, 169))        tmp.paste(overlay_image,(0, 0), overlay_image)        # overlay_image = Image.open(overlay_image_path)        c = Image.new('RGBA', overlay_image.size, (255, 255, 255, 0))        # tmp.alpha_composite(img,overlay_image)        compositedList.append(tmp)        # img = cv2.imread(tmp)        # video.write(img)        # os.remove(i)        print("REMOVE :" + str(i))        tmp.save(dirMov+str("{0:05d}".format(count))+'.png', 'PNG', quality=100, optimize=True)        count += 1    # video.release()    print("Video encoded")def encodeToMp4(sortedList):    # seqList = glob2.glob('/Users/Yu/Pictures/digiCamControl/Session1/*.jpg')    # fourcc = cv2.VideoWriter_fourcc('M', 'P', '4', 'V')    # video = cv2.VideoWriter(dirMov + 'video.mp4', fourcc, 10.0, (1080, 1080))    #    # for i in sortedList:    #     img = cv2.imread(i)    #    #     video.write(img)    #     # os.remove(i)    #     print("REMOVE :" + str(i))    #    # video.release()    # print("Video encoded")    pass""""""def uploadToDropbox(url):    pass    # def process_folder_entries(current_state, entries):    #     for entry in entries:    #         if isinstance(entry, dropbox.files.FileMetadata):    #             current_state[entry.path_lower] = entry    #         elif isinstance(entry, dropbox.files.DeletedMetadata):    #             current_state.pop(entry.path_lower, None)  # ignore KeyError if missing    #     return current_state    #    # def path_exists(path):    #     try:    #         dbx.files_get_metadata(path)    #         return True    #     except ApiError as e:    #         if e.error.get_path().is_not_found():    #             return False    #         raise    #    # print("Initializing Dropbox API...")    # dbx = dropbox.Dropbox("<ACCESS TOKEN>")    #    # print("Scanning for expense files...")    # result = dbx.files_list_folder(path="")    # files = process_folder_entries({}, result.entries)    #    # # check for and collect any additional entries    # while result.has_more:    #     print("Collecting additional files...")    #     result = dbx.files_list_folder_continue(result.cursor)    #     files = process_folder_entries(files, result.entries)    #    # for entry in files.values():    #     # use modified time of file to build destination path    #     destination_path = posixpath.join(    #         "/" + str(entry.client_modified.year) + "_Expenses",    #         str(entry.client_modified.month)    #     )    #    #     # check to see if we need to create the destination folder    #     if not path_exists(destination_path):    #         print("Creating folder: {}".format(destination_path))    #         dbx.files_create_folder(destination_path)    #    #     print("Moving {} to {}".format(entry.path_display, destination_path))    #     dbx.files_move_v2(entry.path_lower, destination_path + "/" + entry.name)    # print("Complete!")    #    # # ................................................................    # dbx.users_get_current_account()    # f = open('<アップロードするローカルファイルのパスを指定>', 'rb')    # dbx.files_upload(f.read(), '<Dropbox上でのファイルパスを指定>')    # f.close()"""bottle server にリダイレクト用のページを作成。ページを開くとダウンロード。ダウンロードされない場合ボタンを作成。"""def createQR(path):    pass    # img = qrcode.make(path)    #    # print(type(img))    # print(img.size)    # # <class 'qrcode.image.pil.PilImage'>    # # (290, 290)    #    # img.save('data/qr/qrcode_test.png')""""""def showQR():    pass"""別フォルダを作成しイメージをバックアップする"""def backup():    passdef main():    # deleteAllImages()    print("##### "+str(getImageList()))    l = getImageList()    m = rename(l)    print(str(m))    # l_reverse = copy.deepcopy(l)    # l_reverse.sort(reverse=True)    # l.append(l_reverse)    img = Image.open("./data/footer.png")    # compositeImage(m, img)    # 入力    a_in =ffmpeg.input('data/audio.mp4')    a = a_in['a']    stream = ffmpeg.input(dirMov+'*.png', pattern_type='glob', framerate=10)    # s = ffmpeg.overlay(stream,'data/footer.png')    # 出力    stream = ffmpeg.output(stream, a, '/Users/yu_mbp/Desktop/out.mp4',vcodec='libx264', pix_fmt='yuv420p', t=8, r=5, f='mp4')    # 実行    ffmpeg.run(stream)if __name__ == '__main__':    main()