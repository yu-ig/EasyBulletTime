# coding : utf-8import ffmpegimport glob2import osimport shutilimport numpy as npimport copyfrom PIL import Image, ImageFilter, ImageDraw# import dropboximport posixpath# from dropbox.exceptions import ApiError# import qrcodeimport pygamefrom pygame.locals import *import sysimport subprocesslist_tmpSerialNum = ["Canon EOS Kiss X8i (211032004233)","Canon EOS Kiss X8i (211032004234)","Canon EOS Kiss X8i (211032004209)","Canon EOS Kiss X8i (211032004210)","Canon EOS Kiss X8i (211032004212)","Canon EOS Kiss X8i (211032004211)","Canon EOS Kiss X8i (211032004213)","Canon EOS Kiss X8i (211032004214)","Canon EOS Kiss X8i (211032004230)","Canon EOS Kiss X8i (211032004229)","Canon EOS Kiss X8i (211032004228)","Canon EOS Kiss X8i (211032004227)","Canon EOS Kiss X8i (211032004238)","Canon EOS Kiss X8i (211032004237)","Canon EOS Kiss X8i (211032004235)","Canon EOS Kiss X8i (211032004236)","Canon EOS Kiss X8i (211032004166)","Canon EOS Kiss X8i (211032004162)","Canon EOS Kiss X8i (211032004164)","Canon EOS Kiss X8i (211032004165)","Canon EOS Kiss X8i (211032004232)","Canon EOS Kiss X8i (211032004231)","Canon EOS Kiss X8i (211032004161)"]list_serialNum = np.array(list_tmpSerialNum)# Setting Pathdir = '/Users/yu_mbp/Desktop/Session1/'dirMov = '/Users/yu_mbp/Desktop/mp4/'copyDir = '/Users/yu_mbp/Desktop/copy/'count = 0""""""def getImageList():    fList = glob2.glob(dir + '*.jpg')    num = len(list_serialNum)    list_cam = []    for i in range(23):        l = []        list_cam.append(l)    for i in range(num):        # dir = '/Users/Yu/Pictures/digiCamControl/Session1\\'        file_name = dir + str(list_serialNum[i])        n = len(fList)        for j in range(n):            # print("LIST : "+f)            if fList[j].find(list_serialNum[i]) > -1:                # os.remove(dir + str("{0:02d}".format(j))+".jpg")                # f = os.rename(fList[i], dir + str("{0:02d}".format(j))+".jpg")                list_cam[i].append(fList[j])                # print("RENAME : "+dir + str("{0:04d}".format(j))+".jpg")        print(str(i) +' : ' + str(list_cam[i]))    return list_cam""""""def deleteAllImages(directory):    l = glob2.glob(directory+'*')    for i in l:        os.remove(i)        print("DELETE : "+i)def sorting(camList):    sortedList = []    count = 0    l1 = camList[1]    print("camList[0] : "+str(len(l1)))    bts = []  # 各バレットタイムのリスト    n = len(l1)    for i in range(n):   #3        bt = []  # 一つのバレットタイム        for imgList in camList:  #23            imgList.sort()            print("i "+str(i))            tmp = imgList[i]            #sortedList.append(tmp)            bt.append(tmp)            # f = os.rename(camList[i], dir+str("{0:04d}".format(count))+'.jpg')            # sortedList.append(f)            # print("RENAME : "+dir+str("{0:04d}".format(count))+'.jpg')            # count+=1        bts.append(bt)        # camList.sort(reverse=True)        # for imgList in camList:        #     tmp = imgList[i]        #     sortedList.append(tmp)        #     # count+=1    # 反転したリストを作成する　#####################################################    repeat = len(bts)    numImgs = len(bts[0])    print("numImgs :" + str(numImgs))    invBts = []    for i in range(repeat):        invBt = []        # リストの初期化        for init in range(numImgs):            invBt.append("0")        # リストの中身を反転        bt = bts[i]        print("len(invBt) :"+str(len(invBt)))        for tmp in range(numImgs):            v = numImgs-tmp-1            print("v :"+ str(v))            invBt[v] = bt[tmp]        invBts.append(invBt)    # 一つのリストに合成 ##############################################################    for i in range(n):        for j in range(numImgs):            bt = bts[i]            sortedList.append(bt[j])        for j in range(numImgs):            invBt = invBts[i]            # if j % 3 == 0:            #     sortedList.append(invBt[j])            sortedList.append(invBt[j])    print(str(sortedList))    return sortedListdef rename(sortedList) :    newList = []    count = 0    for fileName in sortedList:        f = shutil.copy2(fileName, copyDir+str("{0:05d}".format(count))+'.jpg')        newList.append(f)        count +=1        print("EXPORT : "+f)    return newList''''''def resize(sortedList):    count = 0    for f in sortedList:        print(f)        resizeCmd = "ffmpeg -i "+f +" -s 1080:720 -q 2 "+ copyDir+"_"+str("{0:05d}".format(count))+'.jpg'        subprocess.call(resizeCmd.split())        print("resize")        count += 1def compositeImage(sortedList, overlay_image):    result = "result/test_output.m4v"    # fps = movie.get(cv2.CAP_PROP_FPS)    # height = movie.get(cv2.CAP_PROP_FRAME_HEIGHT)    # width = movie.get(cv2.CAP_PROP_FRAME_WIDTH)    fps = 10    # fourcc = cv2.VideoWriter_fourcc('m', 'p', '4', 'v')    # video = cv2.VideoWriter(dirMov + 'video.mp4', fourcc, 10.0, (1080, 1080))    #    compositedList = []    size = (1080, 1080)    tmp = Image.new("RGBA", size, (0, 0, 0))    # out = cv2.VideoWriter(result, int(fourcc), fps, size)    np_list = np.array(sortedList)    count = 0    for i in np_list:        s = (1080, 720)        img = Image.open(i)        img_resize = img.resize(s, resample=0)        tmp.paste(img_resize, (0, 169))        tmp.paste(overlay_image,(0, 0), overlay_image)        # overlay_image = Image.open(overlay_image_path)        # c = Image.new('RGBA', overlay_image.size, (255, 255, 255, 0))        # tmp.alpha_composite(img,overlay_image)        # compositedList.append(tmp)        # img = cv2.imread(tmp)        # video.write(img)        # os.remove(i)        print("REMOVE :" + str(i))        tmp.save(dirMov+str("{0:05d}".format(count))+'.png', 'PNG', quality=100, optimize=True)        count += 1    # video.release()    print("Video encoded")""""""def rapidComp():    passdef encodeToMp4(sortedList):    # 入力    a_in = ffmpeg.input('data/audio.mp4')    a = a_in['a']    stream = ffmpeg.input(dirMov + '*.png', pattern_type='glob', framerate=10)    # s = ffmpeg.overlay(stream,'data/footer.png')    # 出力    stream = ffmpeg.output(stream, a, '/Users/yu_mbp/Desktop/out.mp4', vcodec='libx264', pix_fmt='yuv420p', t=20, r=5,                           f='mp4')    # 実行    ffmpeg.run(stream)    pass""""""def uploadToDropbox(url):    pass    # def process_folder_entries(current_state, entries):    #     for entry in entries:    #         if isinstance(entry, dropbox.files.FileMetadata):    #             current_state[entry.path_lower] = entry    #         elif isinstance(entry, dropbox.files.DeletedMetadata):    #             current_state.pop(entry.path_lower, None)  # ignore KeyError if missing    #     return current_state    #    # def path_exists(path):    #     try:    #         dbx.files_get_metadata(path)    #         return True    #     except ApiError as e:    #         if e.error.get_path().is_not_found():    #             return False    #         raise    #    # print("Initializing Dropbox API...")    # dbx = dropbox.Dropbox("<ACCESS TOKEN>")    #    # print("Scanning for expense files...")    # result = dbx.files_list_folder(path="")    # files = process_folder_entries({}, result.entries)    #    # # check for and collect any additional entries    # while result.has_more:    #     print("Collecting additional files...")    #     result = dbx.files_list_folder_continue(result.cursor)    #     files = process_folder_entries(files, result.entries)    #    # for entry in files.values():    #     # use modified time of file to build destination path    #     destination_path = posixpath.join(    #         "/" + str(entry.client_modified.year) + "_Expenses",    #         str(entry.client_modified.month)    #     )    #    #     # check to see if we need to create the destination folder    #     if not path_exists(destination_path):    #         print("Creating folder: {}".format(destination_path))    #         dbx.files_create_folder(destination_path)    #    #     print("Moving {} to {}".format(entry.path_display, destination_path))    #     dbx.files_move_v2(entry.path_lower, destination_path + "/" + entry.name)    # print("Complete!")    #    # # ................................................................    # dbx.users_get_current_account()    # f = open('<アップロードするローカルファイルのパスを指定>', 'rb')    # dbx.files_upload(f.read(), '<Dropbox上でのファイルパスを指定>')    # f.close()"""bottle server にリダイレクト用のページを作成。ページを開くとダウンロード。ダウンロードされない場合ボタンを作成。"""def createQR(path):    pass    # img = qrcode.make(path)    #    # print(type(img))    # print(img.size)    # # <class 'qrcode.image.pil.PilImage'>    # # (290, 290)    #    # img.save('data/qr/qrcode_test.png')""""""def showQR():    pass"""別フォルダを作成しイメージをバックアップする"""def backup():    passdef main():    # deleteAllImages()    print("##### "+str(getImageList()))    l = getImageList()    m = sorting(l)    print(str(m))    t = rename(m)    # resize(t)    # l_reverse = copy.deepcopy(l)    # l_reverse.sort(reverse=True)    # l.append(l_reverse)    img = Image.open("./data/footer.png")    # compositeImage(m, img)    # # 入力    # a_in =ffmpeg.input('data/audio.mp4')    # a = a_in['a']    # # stream = ffmpeg.input(dirMov+'*.png', pattern_type='glob', framerate=10)    # stream = ffmpeg.input(copyDir + '*.jpg', pattern_type='glob', framerate=10)    # # s = ffmpeg.overlay(stream,'data/footer.png')    #    # # 出力    # stream = ffmpeg.output(stream, a, '/Users/yu_mbp/Desktop/out2.mp4',vcodec='libx264', pix_fmt='yuv420p', t=14, r=5, f='mp4')    #    # # 実行    # ffmpeg.run(stream)    resizeCmd = "ffmpeg -r 10 -i " +str(copyDir) +"%05d.jpg -i data/audio.mp4 -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 -vcodec libx264 -pix_fmt yuv420p -f mp4 -t 14 -s 1080:720 -q 2  "+str(dirMov)+"out3.mp4"    # resizeCmd = "ffmpeg -i /Users/yu_mbp/Desktop/out2.mp4 -s 1080:720 -q 2 /Users/yu_mbp/Desktop/out3.mp4"    subprocess.call(resizeCmd.split())    cmd = "ffmpeg -i ./data/footer.png -i "+str(dirMov)+"out3.mp4 -filter_complex overlay=x=0:y=169 -preset ultrafast  /Users/yu_mbp/Desktop/out4.mp4 "    subprocess.call(cmd.split())if __name__ == '__main__':    main()    deleteAllImages(copyDir)    print("FINISHED")